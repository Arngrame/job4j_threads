## 3.1.1 Thread
### 3.1.1.1 Threads
Многопоточность/параллелизм - способность ОС выполнять задачи параллельно при условии наличия нескольких процессоров/ядер на компьютере. Чем их больше, тем больше задач может выполняться одновременно.

Многозадачность - несколько задач выполняются попеременно на одном ядре CPU. Это достигается за счёт быстрого переключения между задачами, на которые планировщик выделяет кванты времени (5-100ms).<br>

Процесс - изолированный экземпляр запущенной программы (задача), имеющий свои ресурсы. Процессы не могут обмениваться данными между собой, т.к. это независимые друг от друга элементы.<br>
Нить/поток - абстракция над процессом / "подпроцесс". Потоки делят между собой ресурсы процесса и обмениваются данными.

### 3.1.1.2 Создание и запуск нити
Для создания потока используется класс java.lang.Thread <br>

Thread#currentThread() - статический метод, получающий экземпляр текущего потока выполнения. <br>
Thread#currentThread()#getName() - получение имени текущего потока выполнения. <br>
Thread#start() - указание для JVM о том, что операторы, описанные в конструкторе Thread(Runnable run) нужно выполнить в отдельном потоке. <br>
Runnable - функциональный интерфейс с методом run, внутренние операторы которого будут выполнены в многопоточной среде.

Пример с созданием через lambda:
```java
Thread t = new Thread(
        () -> System.out.println(Thread.currentThread().getName())
);
```

Пример с созданием через анонимный класс:
```java
Thread t = new Thread(
        new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName())
            }
        }
);
```

## 3.1.1.3 Состояние нити
Нити имеют следующие состояния:
- NEW: Поток создан, но ещё не запущен. Возникает сразу после создания объекта Thread, но до вызова метода start(). В этом состоянии поток не готов к выполнению и не потребляет системные ресурсы. <br>
Пример:
```java
Thread thread = new Thread(() -> System.out.println("Hello!"));
System.out.println(thread.getState()); // NEW
```

- RUNNABLE: поток запущен, но не обязательно выполняется в данный момент. Включает в себя два подсостояния: Ready (ждёт CPU от планировщика) и Running (выполняется на CPU). <br>
Пример:
```java
thread.start();
System.out.println(thread.getState()); // RUNNABLE
```
- BLOCKED: Поток переходит в это состояние, если он пытается войти в синхронизированный блок или метод, доступ к которому в данный момент удерживается другим потоком. Как только монитор освобождается, поток возвращается в состояние RUNNABLE. <br>
Пример:
```java
Object lock = new Object();

Thread thread1 = new Thread(() -> {
    synchronized (lock) {
        while (true); // Бесконечный цикл (удерживает lock)
    }
});

Thread thread2 = new Thread(() -> {
    synchronized (lock) { // Блокируется, пока thread1 не отпустит lock
        System.out.println("Захватил lock!");
    }
});

thread1.start();
thread2.start();
Thread.sleep(100);
System.out.println(thread2.getState()); // BLOCKED
```

- WAITING: Поток находится в состоянии ожидания без указания времени, пока другой поток не разбудит его. Это происходит при вызове методов Object.wait(), Thread.join() без таймаута или LockSupport.park(). Поток остаётся в этом состоянии, пока не получит уведомление или пока другой поток не завершится (в случае join()). <br>
Пример:
```java
Thread thread1 = new Thread(() -> {
    synchronized (lock) {
        try {
            lock.wait(); // Переходит в WAITING
        } catch (InterruptedException e) {}
    }
});

thread1.start();
Thread.sleep(100);
System.out.println(thread1.getState()); // WAITING
```

- TIMED_WAITING: Похожее на состояние WAITING, но с указанным временем ожидания. Поток переходит в это состояние при вызове методов sleep(), wait() или join() с указанием таймаута. По истечении времени ожидания поток автоматически возвращается в состояние RUNNABLE.<br>
Пример:
```java
Thread thread = new Thread(() -> {
    try {
        Thread.sleep(1000); // TIMED_WAITING
    } catch (InterruptedException e) {}
});

thread.start();
Thread.sleep(100);
System.out.println(thread.getState()); // TIMED_WAITING
```

- TERMINATED: Поток переходит в это состояние, когда метод run() завершает своё выполнение либо из-за нормального завершения, либо из-за неперехваченного исключения. В этом состоянии поток больше не может быть перезапущен.<br>
Пример:
```java
Thread thread = new Thread(() -> System.out.println("Done!"));
thread.start();
thread.join(); // Ждем завершения
System.out.println(thread.getState()); // TERMINATED
```

![img.png](img/thread-lifecycle.png)

### 3.1.1.4 Режим ожидания
Для приостановления нити используется метод Thread#sleep(milliseconds).<br>
Особенности:
- этот метод переводит поток в состояние TIMED_WAITING;
- метод может выбросить исключение InterruptedException - это связано с тем, что поток могут прервать и это потребует предусмотреть дальнейшие действия. <br>

Символ \r указывает возврат каретки в начало строки (это позволяет обновить строку через промежутки времени).

### 3.1.1.5 Прерывание нити
Нить можно приостановить / прервать. В Java есть методы, связанные с этой операцией:
- thread#interrupt() - рекомендация JVM о том, чтобы нить завершила работу. Этот метод ТОЛЬКО выставляет флаг и не совершает никаких дополнительных действий по приостановке потока.
- Thread.currentThread().isInterrupted() - проверка состояния флага и ничего более
- thread#interrupted() - сброс статуса прерывания после проверки флага


### 3.1.1.6 Прерывание блокированной нити
Метод Thread#interrupt(), вызванный в методах sleep, join, wait, не выставляет прерывания, если нить в режиме ожидания, сна или заблокирована другим схожим вызовом.<br>
В таких случаях, эти методы выбрасывают исключение InterruptedException. Соответственно, в блоке catch НЕОБХОДИМО дополнить проставлять флаг прерывания Thread#interrupt.<br>
InterruptedException нужно для прерывания потока, выполняющего блокирующий вызов (sleep, join, wait). Это исключения является единственным способом прерывания метода без возврата какого-либо значения, не нарушая его контракт.

Пример с вечным циклом: [ThreadStop.java](src%2Fmain%2Fjava%2Fru%2Fjob4j%2Fconcurrent%2Ftasks%2Fthread_interrupt_blocked%2FThreadStop.java)
Исправляется вызовом Thread#currentThread()#interrupt() - при использовании блокирующих методов вызов метода interrupt() является необходимым.

### 3.1.1.7 Приоритеты нитей и нити-демоны
У нитей есть приоритеты (значения от 1 до 10 в порядке возрастания важности). Приоритет используется планировщиком нитей для того,
чтобы определять какой нити в данный момент разрешать работать. Согласно планированию нитей, более приоритетные должны исполняться первыми, а остальные
по уменьшению приоритетов. При одинаковом приоритете нити работают по кругу.

В реальности это не совсем так, ибо на выделение ресурсов на работу нити влияет множество факторов (реализация многопоточности в ОС как минимум), поэтому предугадать работу многопоточного приложения,
опираясь только на приоритеты потоков - ошибочно.

Особенности:
- для установки приоритета потоку используется метод thread#setPriority(int level);
- для получения приоритета используется метод getPriority()

**Потоки-демоны**
Существует два типа потоков: пользовательские и демоны:
- пользовательские являются более приоритетными;
- JVM завершает работу пользовательского потока по завершению его задачи;
- при наличии пользовательских потоков после завершения метода main - JVM даст им выполниться;
- каждый тип потока порождает только такой же дочерний тип потока;
- чтобы сделать поток демоном, используется метод setDaemon(true) и это нужно сделать перед запуском потока (перед #start());
- для проверки того, что поток - демон, используется метод #isDaemon();
- потоки демоны - низкоприоритетные, выполняют фоновую/сервисную работу (сборка мусора, очистка кэша, освобождение памяти и т.д.);
- при завершении работы JVM, работа демон-потоков обрывается;
- крайне не рекомендуется использовать потоки-демоны для I/O задач.

### 3.1.1.9 ThreadLocal
ThreadLocal - это переменная, копия которой доступна локально внутри каждой потока. Особенности:
- отличается от своих обычных аналогов-переменных тем, что каждый поток, обращающийся к ThreadLocal, будет иметь свою независимо инициализированную копию переменной (данные, записанные в эту переменную в одной потоке, не будут видны в других);
- применяется:
  - при хранении информации передаваемой по цепочке методов (сессия пользователя);
  - при реализации счетчика для потоков;
  - при кэшировании непотокобезопасных ресурсов (многопоточный потокобезопасный кэш - дорогая задача из-за синхронизации при каждом обращении к кэшу)
- изолирует только ссылки на объекты. Если в разных потоках записать в эту переменную один и тот же объект, то при работе с ним проявятся все проблемы многопоточности

## 3.1.2 Общие ресурсы
### 3.1.2.0 Что такое атомарность?
Атомарность - это свойство группы операций, которые выполняются неразрывно, как логическая единица.<br>
Операция инкремента счётчика не атомарна. Определить не атомарные операции просто. Все операции, где данные зависят от 
начального состояния не атомарны. Эти операции можно описать через процесс "проверить и выполнить".

Пример: [CountShareMain.java](src%2Fmain%2Fjava%2Fru%2Fjob4j%2Fcommon%2Ftasks%2Fatomicity%2FCountShareMain.java)
Изменение переменной посредством неатомарной операцией приводит к тому, что значение не соответствует ожидаемому.

### 3.1.2.1 Синхронизация общих ресурсов
Синхронизация блокирует одновременный доступ к методам. <br>
Одним из способов это сделать - использовать ключевое слово synchronized в сигнатуре метода после модификатора доступа.
```java
public synchronized void increment() {
    value++;
}
```

В таком случае, вызов СИНХРОНИЗИРОВАННОГО метода increment() двумя и более потоками приводит к тому, что
только одна нить работает с этим методом, а остальные уходят в режим блокировки до окончания работы нити, захватившей этот метод.
По сути - синхронизация делает параллельную программу последовательной.

**Критическая секция** <br>
Код в блоке или методе synchronized называется критической секцией - областью памяти, с которой одновременно
может работать только один поток. JVM использует мониторы для регулирования эксклюзивного доступа. Как
только поток заходит в synchronized МЕТОД какого-либо класса, другой поток не сможет зайти НИ В ОДИН synchronized
метод этого класса до тех пор, пока первый поток не освободит занятый им метод.

Особенности:
- в Java есть два механизма указать монитор: явный и неявный;
- synchronized в примере выше - неявный монитор;
- у нестатического synchronized метода монитором является объект этого класса;
- у статического synchronized метода монитором является сам класс.

В примере ниже:
- для lockOfInstance монитор - это объект ShowRoomLock
- для lockOfClass монитор - это сам класс ShowRoomLock
```java
public class ShowRoomLock {    
    public synchronized void lockOfInstance() {/*some logic*/}
    public static synchronized void lockOfClass() {/*some logic*/}
}
```

Ещё один пример ниже с ЯВНЫМИ мониторами (нужно использовать БЛОК synchronized):
- для lockOfInstance монитор - это объект ShowRoomLock
- для lockOfClass монитор - сам класс ShowRoomLock

```java
public class ShowRoomLock {    
    public void lockOfInstance() { 
         synchronized (this) {/*some logic*/}    
    }

    public static void lockOfClass() {
        synchronized (ShowRoomLock.class) {/*some logic*/}
    }
}
```
