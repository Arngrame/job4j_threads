## 3.1 Thread
### 3.1.1 Threads
Многопоточность/параллелизм - способность ОС выполнять задачи параллельно при условии наличия нескольких процессоров/ядер на компьютере. Чем их больше, тем больше задач может выполняться одновременно.

Многозадачность - несколько задач выполняются попеременно на одном ядре CPU. Это достигается за счёт быстрого переключения между задачами, на которые планировщик выделяет кванты времени (5-100ms).<br>

Процесс - изолированный экземпляр запущенной программы (задача), имеющий свои ресурсы. Процессы не могут обмениваться данными между собой, т.к. это независимые друг от друга элементы.<br>
Нить/поток - абстракция над процессом / "подпроцесс". Потоки делят между собой ресурсы процесса и обмениваются данными.

### 3.1.2 Создание и запуск нити
Для создания потока используется класс java.lang.Thread <br>

Thread#currentThread() - статический метод, получающий экземпляр текущего потока выполнения. <br>
Thread#currentThread()#getName() - получение имени текущего потока выполнения. <br>
Thread#start() - указание для JVM о том, что операторы, описанные в конструкторе Thread(Runnable run) нужно выполнить в отдельном потоке. <br>
Runnable - функциональный интерфейс с методом run, внутренние операторы которого будут выполнены в многопоточной среде.

Пример с созданием через lambda:
```java
Thread t = new Thread(
        () -> System.out.println(Thread.currentThread().getName())
);
```

Пример с созданием через анонимный класс:
```java
Thread t = new Thread(
        new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName())
            }
        }
);
```

## 3.1.3 Состояние нити
Нити имеют следующие состояния:
- NEW: Поток создан, но ещё не запущен. Возникает сразу после создания объекта Thread, но до вызова метода start(). В этом состоянии поток не готов к выполнению и не потребляет системные ресурсы. <br>
Пример:
```java
Thread thread = new Thread(() -> System.out.println("Hello!"));
System.out.println(thread.getState()); // NEW
```

- RUNNABLE: поток запущен, но не обязательно выполняется в данный момент. Включает в себя два подсостояния: Ready (ждёт CPU от планировщика) и Running (выполняется на CPU). <br>
Пример:
```java
thread.start();
System.out.println(thread.getState()); // RUNNABLE
```
- BLOCKED: Поток переходит в это состояние, если он пытается войти в синхронизированный блок или метод, доступ к которому в данный момент удерживается другим потоком. Как только монитор освобождается, поток возвращается в состояние RUNNABLE. <br>
Пример:
```java
Object lock = new Object();

Thread thread1 = new Thread(() -> {
    synchronized (lock) {
        while (true); // Бесконечный цикл (удерживает lock)
    }
});

Thread thread2 = new Thread(() -> {
    synchronized (lock) { // Блокируется, пока thread1 не отпустит lock
        System.out.println("Захватил lock!");
    }
});

thread1.start();
thread2.start();
Thread.sleep(100);
System.out.println(thread2.getState()); // BLOCKED
```

- WAITING: Поток находится в состоянии ожидания без указания времени, пока другой поток не разбудит его. Это происходит при вызове методов Object.wait(), Thread.join() без таймаута или LockSupport.park(). Поток остаётся в этом состоянии, пока не получит уведомление или пока другой поток не завершится (в случае join()). <br>
Пример:
```java
Thread thread1 = new Thread(() -> {
    synchronized (lock) {
        try {
            lock.wait(); // Переходит в WAITING
        } catch (InterruptedException e) {}
    }
});

thread1.start();
Thread.sleep(100);
System.out.println(thread1.getState()); // WAITING
```

- TIMED_WAITING: Похожее на состояние WAITING, но с указанным временем ожидания. Поток переходит в это состояние при вызове методов sleep(), wait() или join() с указанием таймаута. По истечении времени ожидания поток автоматически возвращается в состояние RUNNABLE.<br>
Пример:
```java
Thread thread = new Thread(() -> {
    try {
        Thread.sleep(1000); // TIMED_WAITING
    } catch (InterruptedException e) {}
});

thread.start();
Thread.sleep(100);
System.out.println(thread.getState()); // TIMED_WAITING
```

- TERMINATED: Поток переходит в это состояние, когда метод run() завершает своё выполнение либо из-за нормального завершения, либо из-за неперехваченного исключения. В этом состоянии поток больше не может быть перезапущен.<br>
Пример:
```java
Thread thread = new Thread(() -> System.out.println("Done!"));
thread.start();
thread.join(); // Ждем завершения
System.out.println(thread.getState()); // TERMINATED
```

![img.png](img/thread-lifecycle.png)

### 3.1.4 Режим ожидания
Для приостановления нити используется метод Thread#sleep(milliseconds).<br>
Особенности:
- этот метод переводит поток в состояние TIMED_WAITING;
- метод может выбросить исключение InterruptedException - это связано с тем, что поток могут прервать и это потребует предусмотреть дальнейшие действия. <br>

Символ \r указывает возврат каретки в начало строки (это позволяет обновить строку через промежутки времени).

### 3.1.5 Прерывание нити
Нить можно приостановить / прервать. В Java есть методы, связанные с этой операцией:
- thread#interrupt() - рекомендация JVM о том, чтобы нить завершила работу. Этот метод ТОЛЬКО выставляет флаг и не совершает никаких дополнительных действий по приостановке потока.
- Thread.currentThread().isInterrupted() - проверка состояния флага и ничего более
- thread#interrupted() - сброс статуса прерывания после проверки флага


### 3.1.6 Прерывание блокированной нити
Метод Thread#interrupt(), вызванный в методах sleep, join, wait, не выставляет прерывания, если нить в режиме ожидания, сна или заблокирована другим схожим вызовом.<br>
В таких случаях, эти методы выбрасывают исключение InterruptedException. Соответственно, в блоке catch НЕОБХОДИМО дополнить проставлять флаг прерывания Thread#interrupt.<br>
InterruptedException нужно для прерывания потока, выполняющего блокирующий вызов (sleep, join, wait). Это исключения является единственным способом прерывания метода без возврата какого-либо значения, не нарушая его контракт.

Пример с вечным циклом: [ThreadStop.java](src%2Fmain%2Fjava%2Fru%2Fjob4j%2Fconcurrent%2Ftasks%2Fthread_interrupt_blocked%2FThreadStop.java)
Исправляется вызовом Thread#currentThread()#interrupt() - при использовании блокирующих методов вызов метода interrupt() является необходимым.